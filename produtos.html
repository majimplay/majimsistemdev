<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Produtos - Loja</title>
    <style>
        /* Estilos gerais */
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
            background: #f4f4f4;
        }
        .container {
            max-width: 95%; /* Ajustar largura máxima */
            margin: 0 auto;
            padding: 15px; /* Reduzir padding em telas menores */
            box-sizing: border-box; /* Incluir padding na largura total */
        }
        h1.page-title {
            text-align: center;
            margin-bottom: 25px;
            color: #333;
            font-size: 1.8em; /* Ajustar tamanho */
        }

        /* Cabeçalho da Loja */
        .store-header {
            background-color: #e9ecef;
            padding: 12px 18px;
            margin-top: 25px;
            margin-bottom: 20px;
            border-radius: 6px;
            border-left: 6px solid #007BFF;
        }
        .store-header h2 {
            margin: 0;
            font-size: 1.5em;
            color: #0056b3;
        }
         .store-header p {
             margin: 5px 0 0 0;
             font-size: 0.95em;
             color: #555;
         }

        /* Grid de Produtos */
        .product-grid {
            display: grid;
            /* Ajustar colunas para diferentes tamanhos de tela */
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); /* Mínimo menor */
            gap: 25px; /* Aumentar espaçamento */
            padding: 0;
        }

        /* Card de Produto */
        .product-card {
            background: white;
            padding: 0;
            border-radius: 10px; /* Bordas mais arredondadas */
            box-shadow: 0 5px 10px rgba(0,0,0,0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.25s ease, box-shadow 0.25s ease;
        }
         .product-card:hover {
            transform: translateY(-6px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
         }

         /* Conteúdo dentro do card */
         .product-card .product-content {
             padding: 18px; /* Aumentar padding interno */
             flex-grow: 1;
             display: flex;
             flex-direction: column;
             justify-content: space-between;
         }
         .product-card h3 {
            margin: 10px 0 8px 0; /* Ajustar margens */
            font-size: 1.15em;
            color: #333;
            line-height: 1.3; /* Melhorar leitura */
         }
         .product-card .product-description {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 12px;
            min-height: 3.5em; /* Aumentar altura mínima */
            line-height: 1.45;
         }
         .product-card .product-price {
            font-weight: bold;
            color: #007BFF;
            font-size: 1.25em;
            margin-bottom: 18px;
         }
         .product-card button.add-to-cart-btn {
            margin-top: auto;
            padding: 12px 18px; /* Aumentar padding */
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            width: 100%;
            box-sizing: border-box;
            font-size: 1em; /* Aumentar fonte */
            font-weight: 500; /* Leve negrito */
         }
         .product-card button.add-to-cart-btn:hover:not(:disabled) {
            background: #218838;
            transform: scale(1.02); /* Efeito sutil no hover */
         }
          .product-card button.add-to-cart-btn:active:not(:disabled) {
            transform: scale(0.98); /* Efeito ao clicar */
         }
         .product-card button.add-to-cart-btn:disabled {
            background: #b8b8b8; /* Cor mais clara para desabilitado */
            cursor: not-allowed;
            transform: none; /* Sem transform quando desabilitado */
         }

        /* Carrossel */
        .carousel-container {
            position: relative;
            overflow: hidden;
            width: 100%;
            /* Ajustar altura ou usar aspect-ratio */
            height: 0;
            padding-bottom: 80%; /* Proporção 5:4 (ajuste conforme necessário) */
            /* height: 250px; */ /* Altura fixa anterior */
            background-color: #f0f0f0;
        }
        .carousel-track {
            display: flex;
            transition: transform 0.35s ease-in-out; /* Transição mais suave */
            position: absolute; /* Para que o container controle a altura */
            top: 0;
            left: 0;
            width: 100%; /* O track ocupa 100% da largura do container */
            height: 100%; /* O track ocupa 100% da altura definida pelo padding-bottom */
        }
        .carousel-item {
            flex: 0 0 100%;
            display: flex; /* Usar flex para centralizar */
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            height: 100%; /* Ocupa a altura do track */
            overflow: hidden; /* Garante que a imagem não vaze */
        }
        /* FIX: Estilo para o link <a> dentro do carrossel */
        .carousel-item a {
            display: block; /* Faz o link ocupar espaço */
            width: 100%;
            height: 100%;
            display: flex; /* Para centralizar a imagem dentro do link */
            justify-content: center;
            align-items: center;
        }
        .carousel-item img {
            /* Manter proporção e caber dentro do container */
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain; /* Garante que toda a imagem seja visível */
            display: block; /* Remove espaço extra */
            border-radius: 0; /* Sem bordas arredondadas na imagem do carrossel */
        }
        .carousel-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.45);
            border: none;
            color: white;
            padding: 8px 12px; /* Ajustar padding */
            cursor: pointer;
            border-radius: 50%;
            z-index: 10; /* Acima da imagem */
            opacity: 0.6;
            transition: opacity 0.2s ease, background-color 0.2s ease;
            font-size: 1.2em; /* Tamanho do ícone */
        }
         .carousel-button:hover {
            opacity: 1;
            background: rgba(0,0,0,0.6);
         }
        .carousel-button.prev { left: 12px; }
        .carousel-button.next { right: 12px; }

        /* Indicador de Carregamento */
        #loadingIndicator {
            text-align: center;
            padding: 50px;
            font-size: 1.3em;
            color: #666;
            display: block; /* Garantir que está visível inicialmente */
        }
        #loadingIndicator.hidden {
            display: none; /* Classe para esconder */
        }

        /* Mensagem de erro */
        #errorMessage {
            text-align: center;
            padding: 20px;
            color: #dc3545; /* Vermelho */
            background-color: #f8d7da; /* Fundo vermelho claro */
            border: 1px solid #f5c6cb; /* Borda vermelha */
            border-radius: 5px;
            margin: 20px 0;
            display: none; /* Escondido por padrão */
        }

        /* Responsividade */
        @media (max-width: 768px) {
            h1.page-title {
                font-size: 1.6em;
            }
            .product-grid {
                grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); /* Menor em tablets */
                gap: 20px;
            }
             .carousel-button {
                 padding: 6px 10px;
                 font-size: 1.1em;
             }
             .product-card .product-content {
                 padding: 15px;
             }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            h1.page-title {
                font-size: 1.4em;
            }
            .product-grid {
                /* Uma coluna em telas muito pequenas */
                grid-template-columns: 1fr;
                gap: 15px;
            }
             .product-card button.add-to-cart-btn {
                padding: 10px 15px;
                font-size: 0.95em;
            }
             .carousel-container {
                 padding-bottom: 100%; /* Imagem quadrada em mobile */
             }
        }

    </style>
    <script src="https://unpkg.com/parse/dist/parse.min.js"></script>
</head>
<body>
<div class="container">
    <h1 class="page-title">Produtos à Venda</h1>

    <div id="loadingIndicator">Carregando produtos... ⏳</div>
    <div id="errorMessage"></div>
    <div id="storeProductGrid"></div>
</div>

<script>
    // --- Configurações Parse (Back4App) ---
    // !! IMPORTANTE: Substitua pelas suas chaves REAIS do Back4App !!
    const PARSE_APP_ID = "TYP8SUA8qxmHIRs1mHbiFalgRxCEf51sOiSWmNEY"; // Substitua pelo seu Application ID
    const PARSE_JS_KEY = "n4Gfko9sO7jiAUnWX5U5GGCDQ5QtPWX97K4TzB8I"; // Substitua pelo seu Javascript Key
    const PARSE_SERVER_URL = "https://parseapi.back4app.com/";
    Parse.initialize(PARSE_APP_ID, PARSE_JS_KEY);
    Parse.serverURL = PARSE_SERVER_URL;

    // --- Variáveis Globais ---
    const carouselIndexes = {}; // Mantém o índice atual de cada carrossel
    let currentUser = null; // Será definido se o usuário estiver logado no Parse

    // --- Elementos DOM ---
    const gridContainer = document.getElementById("storeProductGrid");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const errorMessageDiv = document.getElementById("errorMessage");

    // --- Funções ---

    /**
     * Exibe uma mensagem de erro na interface.
     * @param {string} message - A mensagem de erro a ser exibida.
     */
    function displayError(message) {
        if (errorMessageDiv) {
            errorMessageDiv.textContent = `❌ Erro: ${message}`;
            errorMessageDiv.style.display = 'block';
        }
        console.error("Erro exibido:", message);
    }

    /**
     * Adiciona um produto ao carrinho do Cliente associado ao usuário logado no Parse.
     * @param {string} produtoId - O objectId do produto a ser adicionado.
     * @param {HTMLElement} buttonElement - O botão que foi clicado.
     */
    async function addToCart(produtoId, buttonElement) {
        // Verifica se o usuário está logado no Parse SDK
        currentUser = Parse.User.current(); // Pega o usuário Parse atual (pode ser null)
        if (!currentUser) {
            alert("⚠️ Você precisa estar logado para adicionar itens ao carrinho.\nFaça login na página principal.");
            console.warn("[Add Cart] Tentativa de adicionar ao carrinho sem usuário Parse logado.");
            return;
        }

        // Feedback visual inicial
        buttonElement.disabled = true;
        buttonElement.textContent = 'Adicionando...';
        console.log(`[Add Cart] Iniciando: Adicionar produto ${produtoId} ao carrinho do usuário ${currentUser.id}`);

        try {
            // 1. Busca o objeto 'Cliente' associado ao usuário logado.
            //    É crucial que a classe 'Cliente' e o campo ponteiro 'usuario' existam no Back4App
            //    e que as permissões (ACL/CLP) permitam ao usuário encontrar e atualizar seu próprio Cliente.
            const Cliente = Parse.Object.extend("Cliente");
            const query = new Parse.Query(Cliente);
            query.equalTo("usuario", currentUser); // Filtra pelo ponteiro para o usuário atual
            let cliente = await query.first(); // Tenta encontrar o Cliente existente

            // 2. Se o Cliente não existir, cria um novo.
            //    Isso pode falhar se as permissões da classe _User não permitirem
            //    a leitura de dados pelo próprio usuário ou se a classe Cliente tiver CLPs restritivas.
            if (!cliente) {
                console.warn(`[Add Cart] Cliente não encontrado para o usuário ${currentUser.id}. Criando um novo...`);
                cliente = new Cliente();
                cliente.set("usuario", currentUser); // Associa o novo Cliente ao usuário logado
                cliente.set("carrinhoclient", []); // Inicializa o carrinho como um array vazio

                // **IMPORTANTE: Definir ACLs para o novo Cliente**
                // Garante que APENAS o usuário dono possa ler e escrever em seu próprio carrinho.
                const acl = new Parse.ACL();
                acl.setReadAccess(currentUser, true);  // Usuário pode ler
                acl.setWriteAccess(currentUser, true); // Usuário pode escrever
                // Opcional: Se administradores precisam de acesso (requer Master Key ou Role):
                // acl.setRoleReadAccess("admin", true);
                // acl.setRoleWriteAccess("admin", true);
                cliente.setACL(acl);

                try {
                    await cliente.save(); // Salva o novo Cliente no Back4App
                    console.log(`[Add Cart] Novo Cliente criado com sucesso (ID: ${cliente.id}) para usuário ${currentUser.id}`);
                } catch (saveError) {
                    console.error(`[Add Cart] Erro CRÍTICO ao salvar NOVO Cliente (verifique ACLs da classe Cliente e _User):`, saveError);
                    displayError(`Não foi possível criar seu carrinho. (${saveError.message}). Tente recarregar a página.`);
                    buttonElement.disabled = false;
                    buttonElement.textContent = 'Adicionar ao Carrinho';
                    return; // Aborta a operação
                }
            } else {
                console.log(`[Add Cart] Cliente existente encontrado (ID: ${cliente.id}) para usuário ${currentUser.id}`);
            }

            // 3. Adiciona o ID do produto ao array 'carrinhoclient'.
            //    Use 'addUnique' se não quiser permitir duplicatas do mesmo produto.
            //    Use 'add' se permitir adicionar o mesmo item várias vezes.
            //    **IMPORTANTE:** Verifique o nome exato do campo array no Back4App (ex: 'carrinhoclient').
            cliente.addUnique("carrinhoclient", produtoId); // Adiciona sem duplicatas
            // cliente.add("carrinhoclient", produtoId); // Use este se permitir duplicatas

            // 4. Salva a atualização no objeto Cliente.
            //    Isso requer permissão de escrita para o usuário no objeto Cliente (definido pela ACL).
            await cliente.save();
            console.log(`[Add Cart] Produto ${produtoId} adicionado ao array 'carrinhoclient' do Cliente ${cliente.id}`);

            // 5. Calcula a nova contagem de itens no carrinho.
            const updatedCartClient = cliente.get("carrinhoclient") || []; // Pega o array atualizado
            const newCount = updatedCartClient.length;
            console.log(`[Add Cart] Sucesso! Novo total de itens no carrinho: ${newCount}`);

            // 6. Envia mensagem para a página pai (index.html) atualizar o contador.
            //    A página pai deve ter um listener para 'message' que espera por { type: 'cartUpdate', count: newCount }.
            //    Use a origem específica em produção! Ex: 'https://seu-dominio.com'
            window.parent.postMessage({ type: 'cartUpdate', count: newCount }, '*');
            console.log(`[Add Cart] Mensagem 'cartUpdate' enviada para a página pai com contagem: ${newCount}`);

            // 7. Feedback visual final no botão.
            buttonElement.textContent = 'Adicionado ✔️';
            // Reabilita o botão após um tempo para evitar cliques múltiplos e dar tempo de ler
            setTimeout(() => {
                // Verifica se o botão ainda existe e se o texto não mudou (ex: por limpeza do carrinho)
                if (buttonElement && buttonElement.textContent === 'Adicionado ✔️') {
                    buttonElement.disabled = false;
                    buttonElement.textContent = 'Adicionar ao Carrinho';
                }
            }, 2500); // Tempo em milissegundos (2.5 segundos)

        } catch (error) {
            console.error(`[Add Cart] Erro GERAL ao adicionar produto ${produtoId} para usuário ${currentUser.id}:`, error);
            // Tenta dar uma mensagem mais específica baseada no erro do Parse
            let userMessage = "Erro ao adicionar o produto ao carrinho.";
            if (error.code === Parse.Error.OBJECT_NOT_FOUND) {
                userMessage = "Erro: Não foi possível encontrar os dados do seu carrinho. Tente recarregar.";
            } else if (error.code === 119) { // Código comum para erro de ACL/Permissão
                userMessage = "Erro de permissão ao salvar no carrinho. Verifique as configurações da sua conta.";
            } else {
                userMessage += ` (${error.message})`;
            }
            alert(`❌ ${userMessage}`); // Mostra alerta para o usuário
            displayError(userMessage); // Mostra erro na div de erros também

            // Reabilita o botão imediatamente em caso de erro
            buttonElement.disabled = false;
            buttonElement.textContent = 'Adicionar ao Carrinho';
        }
    }


    /**
     * Carrega Lojas ordenadas por reputação e seus respectivos produtos
     * na ordem definida dentro de cada loja (array 'produtos' na classe Loja).
     */
    async function loadSortedProducts() {
        if (!gridContainer || !loadingIndicator || !errorMessageDiv) {
             console.error("Elementos essenciais da UI (grid, loading, error) não encontrados.");
             return;
        }
        gridContainer.innerHTML = ""; // Limpa conteúdo anterior
        errorMessageDiv.style.display = 'none'; // Esconde erros anteriores
        loadingIndicator.style.display = 'block'; // Mostra carregando
        loadingIndicator.classList.remove('hidden'); // Garante visibilidade

        // Define as classes Parse
        const Loja = Parse.Object.extend("Loja");
        const Produto = Parse.Object.extend("Produto");

        // Query para buscar as Lojas
        const queryLoja = new Parse.Query(Loja);
        queryLoja.descending("reputacao"); // Ordena por reputação (maior primeiro)
        // Seleciona apenas os campos necessários para otimizar a query
        queryLoja.select("nome", "reputacao", "produtos"); // 'produtos' deve ser um array de ObjectIds de Produtos

        try {
            const lojas = await queryLoja.find();
            console.log(`[Load Sorted] Lojas encontradas e ordenadas: ${lojas.length}`);

            if (lojas.length === 0) {
                 gridContainer.innerHTML = "<p style='text-align: center; color: #888;'>Nenhuma loja encontrada.</p>";
                 loadingIndicator.classList.add('hidden'); // Esconde carregando
                 return;
            }

            // Itera sobre cada loja encontrada
            for (const loja of lojas) {
                const lojaId = loja.id;
                const nomeLoja = loja.get("nome") || "Loja Sem Nome";
                const reputacaoLoja = loja.get("reputacao") || 0;
                // Pega o array de IDs de produtos na ordem definida na Loja
                const productIdsInOrder = loja.get("produtos") || [];

                console.log(`[Load Sorted] Processando Loja: ${nomeLoja} (ID: ${lojaId}, Rep: ${reputacaoLoja}), Produtos na ordem: ${productIdsInOrder.length}`);

                // Cria o cabeçalho da loja
                const storeHeader = document.createElement('div');
                storeHeader.className = 'store-header';
                storeHeader.innerHTML = `<h2>${nomeLoja}</h2><p>Reputação: ${reputacaoLoja}</p>`;
                gridContainer.appendChild(storeHeader);

                // Cria um container grid específico para os produtos desta loja
                const productGridForStore = document.createElement('div');
                productGridForStore.className = 'product-grid';
                gridContainer.appendChild(productGridForStore); // Adiciona o grid da loja ao container principal

                // Se a loja tem produtos definidos no array 'produtos'
                if (productIdsInOrder.length > 0) {
                    // Query para buscar os detalhes dos produtos desta loja
                    const queryProduto = new Parse.Query(Produto);
                    // Busca apenas os produtos cujos ObjectIds estão no array 'productIdsInOrder'
                    queryProduto.containedIn("objectId", productIdsInOrder);
                    // Seleciona apenas os campos necessários dos produtos
                    queryProduto.select("nome", "preco", "imagens", "descricao");

                    try {
                        const produtosDestaLoja = await queryProduto.find();
                        console.log(`[Load Sorted] Produtos encontrados para ${nomeLoja} (IDs: ${productIdsInOrder.join(', ')}): ${produtosDestaLoja.length}`);

                        // **Reordena os produtos encontrados** para garantir a ordem exata
                        // definida no array 'productIdsInOrder' da Loja.
                        const produtosOrdenados = productIdsInOrder
                            .map(id => produtosDestaLoja.find(p => p.id === id)) // Encontra o produto correspondente para cada ID na ordem
                            .filter(p => p); // Remove quaisquer 'undefined' caso um ID não seja encontrado (produto deletado?)

                        if (produtosOrdenados.length !== productIdsInOrder.length) {
                             console.warn(`[Load Sorted] Discrepância de IDs para loja ${nomeLoja}. IDs na loja: ${productIdsInOrder.length}, Produtos encontrados/ordenados: ${produtosOrdenados.length}. Alguns produtos podem ter sido removidos.`);
                        }

                        // Renderiza os cards dos produtos ordenados no grid desta loja
                        if (produtosOrdenados.length > 0) {
                            produtosOrdenados.forEach(produto => {
                                 renderProductCard(produto, productGridForStore); // Passa o grid da loja atual
                            });
                        } else {
                            // Mensagem se os IDs existiam mas os produtos não foram encontrados
                            productGridForStore.innerHTML = "<p style='grid-column: 1 / -1; text-align: center; color: #888;'>Nenhum produto ativo encontrado para esta loja (verifique os IDs cadastrados).</p>";
                        }

                    } catch (productError) {
                         console.error(`[Load Sorted] Erro ao buscar produtos para a loja ${nomeLoja} (ID: ${lojaId}):`, productError);
                         productGridForStore.innerHTML = `<p style='grid-column: 1 / -1; text-align: center; color: red;'>Erro ao carregar produtos desta loja.</p>`;
                    }

                } else {
                    // Mensagem se o array 'produtos' da loja estiver vazio
                    productGridForStore.innerHTML = "<p style='grid-column: 1 / -1; text-align: center; color: #888;'>Esta loja ainda não possui produtos cadastrados.</p>";
                }
            } // Fim do loop por lojas

            loadingIndicator.classList.add('hidden'); // Esconde o indicador de carregamento após tudo

        } catch (error) {
            console.error("[Load Sorted] Erro GERAL ao carregar lojas:", error);
            loadingIndicator.classList.add('hidden'); // Esconde carregando
            displayError(`Falha ao carregar as lojas e produtos: ${error.message}`); // Mostra erro na div
            gridContainer.innerHTML = ""; // Limpa o grid em caso de erro fatal
        }
    }

    /**
     * Renderiza um card de produto e o adiciona a um container (grid específico da loja).
     * @param {Parse.Object} produto - O objeto Parse.Object do produto.
     * @param {HTMLElement} container - O elemento HTML (productGridForStore) onde o card será adicionado.
     */
    function renderProductCard(produto, container) {
        const produtoId = produto.id;
        // Garante que 'imagens' seja um array, mesmo que seja null/undefined no Parse
        const imagens = produto.get("imagens") || [];
        const nome = produto.get("nome") || "Produto sem nome";
        const preco = produto.get("preco") || 0;
        const descricao = produto.get("descricao") || ""; // Descrição pode ser vazia

        const card = document.createElement("div");
        card.className = "product-card";
        card.dataset.productId = produtoId; // Adiciona ID do produto ao card para referência

        // --- Carrossel de Imagens ---
        let carouselItemsHTML = '';
        // Se não houver imagens, mostra um placeholder
        if (imagens.length === 0) {
            carouselItemsHTML = `
                <div class="carousel-item">
                    <img src="https://placehold.co/400x320/eee/ccc?text=Sem+Imagem" alt="Sem Imagem">
                </div>`;
        } else {
            // Mapeia cada URL de imagem para um item do carrossel com link
            carouselItemsHTML = imagens.map(url => `
                <div class="carousel-item">
                    <a href="${url}" target="_blank" title="Ver imagem em tamanho real">
                        <img src="${url}" alt="Imagem de ${nome}" loading="lazy" onerror="this.onerror=null; this.src='https://placehold.co/400x320/eee/ccc?text=Erro+Img'; this.alt='Erro ao carregar imagem';">
                    </a>
                </div>`).join("");
        }

        // Adiciona botões de navegação apenas se houver mais de 1 imagem
        const prevButtonHTML = imagens.length > 1 ? `<button class="carousel-button prev" aria-label="Imagem anterior" onclick="moveCarousel(event, '${produtoId}', -1)">&#10094;</button>` : '';
        const nextButtonHTML = imagens.length > 1 ? `<button class="carousel-button next" aria-label="Próxima imagem" onclick="moveCarousel(event, '${produtoId}', 1)">&#10095;</button>` : '';

        // Monta o HTML do carrossel
        const carouselHTML = `
            <div class="carousel-container">
                ${prevButtonHTML}
                <div class="carousel-track" id="track-${produtoId}">
                    ${carouselItemsHTML}
                </div>
                ${nextButtonHTML}
            </div>`;

        // --- Conteúdo do Card (Nome, Descrição, Preço, Botão) ---
        const contentDiv = document.createElement('div');
        contentDiv.className = 'product-content';
        // Usa textContent para evitar XSS em nome e descrição, se vierem de fontes não confiáveis
        const productNameH3 = document.createElement('h3');
        productNameH3.textContent = nome;

        const productDescP = document.createElement('p');
        productDescP.className = 'product-description';
        productDescP.textContent = descricao || ''; // Garante que seja string
        // Adiciona um espaço não quebrável se a descrição for vazia para manter a altura mínima
        if (!productDescP.textContent.trim()) {
            productDescP.innerHTML = '&nbsp;';
        }

        const productPriceP = document.createElement('p');
        productPriceP.className = 'product-price';
        // Formata o preço para o padrão brasileiro (R$)
        productPriceP.textContent = `R$ ${preco.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

        const addToCartButton = document.createElement('button');
        addToCartButton.className = 'add-to-cart-btn';
        addToCartButton.textContent = 'Adicionar ao Carrinho';
        addToCartButton.onclick = () => addToCart(produtoId, addToCartButton); // Passa o elemento botão

        // Agrupa informações antes do botão
        const infoDiv = document.createElement('div');
        infoDiv.appendChild(productNameH3);
        infoDiv.appendChild(productDescP);
        infoDiv.appendChild(productPriceP);

        // Adiciona os elementos ao contentDiv
        contentDiv.appendChild(infoDiv);
        contentDiv.appendChild(addToCartButton);

        // Adiciona o carrossel e o conteúdo ao card principal
        card.innerHTML = carouselHTML; // Insere o HTML do carrossel
        card.appendChild(contentDiv); // Adiciona o div de conteúdo

        // Inicializa o índice do carrossel para este produto
        carouselIndexes[produtoId] = 0;

        // Adiciona o card completo ao container (grid da loja)
        container.appendChild(card);
    }

    /**
     * Move o carrossel de um produto específico.
     * @param {Event} event - O evento do clique (para parar propagação).
     * @param {string} produtoId - O ID do produto do carrossel.
     * @param {number} direction - -1 para anterior, 1 para próximo.
     */
    function moveCarousel(event, produtoId, direction) {
        event.stopPropagation(); // Impede que o clique no botão acione outros eventos (ex: link da imagem)
        event.preventDefault(); // Impede a ação padrão do botão, se houver

        const track = document.getElementById(`track-${produtoId}`);
        if (!track) {
            console.warn(`[Carousel] Track 'track-${produtoId}' não encontrado.`);
            return;
        }
        // Conta os itens diretamente no track
        const totalItems = track.children.length;

        if (totalItems <= 1) return; // Não faz nada se só tiver 1 ou 0 imagens

        // Pega o índice atual ou inicializa com 0
        let currentIndex = carouselIndexes[produtoId] || 0;
        // Calcula o novo índice
        currentIndex += direction;

        // Implementa o loop (vai para o fim se passar do início, vai para o início se passar do fim)
        if (currentIndex < 0) {
             currentIndex = totalItems - 1; // Vai para o último item
        } else if (currentIndex >= totalItems) {
             currentIndex = 0; // Volta para o primeiro item
        }

        // Atualiza o índice armazenado
        carouselIndexes[produtoId] = currentIndex;
        // Aplica a transformação CSS para mover o track
        track.style.transform = `translateX(${-currentIndex * 100}%)`;
        console.log(`[Carousel] Movido para imagem ${currentIndex + 1}/${totalItems} no produto ${produtoId}`);
    }

    // --- Inicialização da Página ---

    // Listener para mensagens da página pai (index.html)
    window.addEventListener('message', (event) => {
         // IMPORTANTE: Em produção, SEMPRE verifique a origem da mensagem por segurança!
         // Ex: if (event.origin !== 'https://SEU_DOMINIO.com') { console.warn("Origem da mensagem ignorada:", event.origin); return; }

        if (event.data && typeof event.data === 'object') {
            switch (event.data.type) {
                case 'cartCleared':
                    console.log("[Message Listener] Recebido 'cartCleared' da página pai. Reabilitando botões 'Adicionar'...");
                    // Reabilita todos os botões que foram deixados como "Adicionado ✔️"
                    const addedButtons = document.querySelectorAll('button.add-to-cart-btn:disabled');
                    addedButtons.forEach(btn => {
                        // Verifica se o texto é 'Adicionado ✔️' antes de reabilitar
                        if (btn.textContent === 'Adicionado ✔️') {
                            btn.disabled = false;
                            btn.textContent = 'Adicionar ao Carrinho';
                        }
                    });
                    break;
                // Adicione outros tipos de mensagens se necessário
                // case 'userInfo':
                //     console.log("[Message Listener] Informações do usuário recebidas:", event.data.user);
                //     // Atualizar UI com base no usuário, se necessário
                //     break;
                 default:
                    // Ignora mensagens desconhecidas
                    // console.log("[Message Listener] Mensagem de tipo desconhecido recebida:", event.data.type);
                    break;
            }
        }
    });

    // Função principal para iniciar o carregamento dos dados
    function initializePage() {
        console.log("[Produtos Init] Página carregada. Iniciando carregamento de produtos...");
        // Verifica o usuário Parse atual (pode ser null se não logado)
        currentUser = Parse.User.current();
        if (currentUser) {
            console.log("[Produtos Init] Usuário Parse logado encontrado:", currentUser.id);
        } else {
            console.log("[Produtos Init] Nenhum usuário Parse logado no momento.");
        }
        // Carrega os produtos. A função addToCart verificará o login novamente no momento do clique.
        loadSortedProducts();
    }

    // Garante que o DOM esteja pronto antes de executar o script principal
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializePage);
    } else {
        // DOM já carregado
        initializePage();
    }

</script>
</body>
</html>
